# Version Control {#py-version-control}

## Questions {#py-version-control-questions}


TODO: questions + keypoints
How do you refer to something? Can someone point me at an example?
When do they set up GitKraken / get a github account / install git? 
Is git capitalized?
Should we talk about .gitignore? 
Can revert commits, but not checkout individual files in the GitKraken interface. 

## Objectives {#py-version-control-objectives}

```{r, child="objectives/py-version-control.md"}
```

## What is Version Control? {#py-version-control-intro}

TODO: picture of file with lots of file names

A version control system is a way to track changes to your files without having 
to make a lot of copies. Wikipedia is a great example of a version control system: each page has a record of all the changes that have been made to the page, who made the changes and when, and a way to compare different versions of the page. 

In our world of data science projects, a good version control system should help us track changes like: 

- adding a new dataset to our analysis
- constantly modifying or updating a same script
- getting comments or feedback from a reader
- keeping backup copies of important files

This chapter will focus on a specific version control tool called "git". Git is a program that can be installed on your computer, and you can use it to handle any of the scenarios listed above. There are other version control programs (CVS, SVN, Mercurial are three examples). We've used git in this chapter because it's commonly used and at least two free, online spaces for hosting version controlled work are set up to use git. 

We'll be using a program called GitKraken to make it easier to use git, in the same way that we used the Spyder IDE to help us write Python code. 

## Creating a Repository {#py-version-control-repo}

To get started with tracking work, it's good to think about what scope of information you want to track. Does it make sense to track all of the files of your computer at once? Probably not. It would be better for the version control system to separately track changes on a per-project basis. In terms of how we have files organized on our computer, that means we want to track changes inside a project folder (and all its sub-folders). 

The mechanism used by git to track work is called a "repository" (or "repo" for short) and so for each project where we want to track changes, we need to create a repository associated with the parent folder of the project. 

In the GitKraken interface, there's a button to do exactly that, over on the left: "Start a local repo". It's possible to use this button to associate a repository with a pre-existing folder, but it's simpler to generate a repository with a new folder in one go, so that's what we'll do. 

TODO: Redo this process so I can describe it
TODO: Screenshot

Once this process succeeds, a few things should happen. You should see a folder called `test` on your computer's desktop and the GitKraken screen will suddently become a lot more complicated. Just like with Spyder, we're going to focus on just a part of the window for now - the right hand pane, and the middle section. 

TODO: Screenshot

At this point, we've created a git repository associated with our project folder. Now if we make any changes in that folder (or a sub-folder!), git will pay attention and be able to track it for us. Let's see what happens if we do this. 

## Tracking Changes {#py-version-control-tracking-changes}

As we add and modify files in our project folder, we want to record our changes. 
This is done by creating "commits" which are like snapshots of the repository at 
moments in time. By building up a history of many commits, each created for a 
different phase of the files in the repository, you can see what changes have happened over time. 

The process of tracking changes in this way has three stages: 

1. Create new files or make changes to existing files in the project repository.
2. Choose the files that you want to create a saved version of (called "staging" or "adding")
3. "Commit" the changes from the previous step. 

TODO: Image of change cycle

To see this in action, create a file called `carbon.py` in your test repository:

```{python}
TODO
```

Look at the right side of the GitKraken interface. You should see a few changes 
in the right hand pane. If you click on "view Change", the right pane will change to show you the list of files that git knows has changed. In this case, it should 
have the new `carbon.py` cycle. 

It's now time to do the second part of the cycle -- *adding* or *staging* files to commit. In the GitKraken interface, this can be done by hitting the "stage all changes" button (which will add *all* the changed files to the list to be committed) or you can click on individual files and then click on the "Stage File" button. 

Once you've done this, the files that are to be added to the commit will be now in the second box of the right pane, the staging area. If you made a mistake and added files you aren't yet ready to snapshot, you can "unstage" them here. Once you have the list of files you want to stage, write a commit message in the third box. Then click on the commit changes to one file. 

We're sent back to our history mode, with the right pane showing us the latest commit. 

Then, as you make changes to `carbon.py` or create new files, go through this 
process again and again. How often should you create new commits after making 
changes? It's a good idea to create commits fairly frequently, so that you have a snapshot of your progress. If changes need to take effect at the same time on a group of files, you should commit them together; if changes are unrelated, it's a good idea to separate them into their own commits. Another way to make version 
control useful: create succinct but meaningful commit messages. While many 
developers can easily slip into commit messages like "@)#(*&#@)(*!", it's 
worth the extra few seconds to type something meangingful, especially when 
it comes to examining previous versions of files. 

## Examining Previous Versions {#py-version-control-examining-versions}

As part of the change-and-commit cycle, we will want to see the difference 
between new and old versions of a file. In other words, instead of just going 
around the cycle in one direction, we want to be able to reverse direction, 
either by rolling back to a previous version, or just examining the differences
between a current version of the file and an older version. We do this by 
finding a commit (or multiple commits) that has the versions of the file 
we want to compare. Those commits are found in the repository's log or history.

If you haven't already, make a few more changes to the `carbon.py` script 
and commit them. Then go through the cycle one more time, so your history 
has at least 3 commits. 

The history of changes (commits_ is in the center pane of the GitKraken 
window. If you click on one of these, you'll see the right hand pane show 
all the information associated with the commit, including the file(s) 
modified in that commit. You can click on the file to see how it appeared in 
that particular commit. 

The file will open in the center pane (replacing the history) and at the 
top will be a toggle between "File View" and "Diff View". If you click on 
the "Diff View" side, the file will show how it changed since the previous 
commit. Additions are indicated with green highlighting and a plus; deletions 
with red highlighting and a minus.

If you want to see *all* the files as they were during a particular commit 
(not just the modified files), select the desired commit and then click the 
"View all files" checkbox in the middle-right of the right-hand pane. 

You can compare in more selective ways by selecting a whole series of commits, 
from the commit history, clicking on the changed file, and looking at how the 
file has changed from the most recent commit you selected to the one preceeding 
the oldest commit you selected. 

Finally, sometimes you may want to return back to a previous version altogether. 
To do this, select the commit you want to return to from the commit history. 
Right click on it and then select "Revert commit". 

TODO: commit changes immediately y/n?

## Online Repositories {#py-version-control-remote}

To this point, we've used git features to track changes and compare versions 
of files in our project repository. An additional way to use git to manage our 
project is to create a duplicate of our project repository online. As we commit 
changes to the project on our computer, we can periodically update the online 
copy so that we have a backup. Sending changes from our computer to an online 
copy is called "pushing" and if we want to get changes from the online copy to 
our computer, the command is called "pulling." In what follows, we'll set up 
a blank online repository and push and pull changes to and from it. 

First, create a blank repository online. (TODO). 
Once this is done, copy the link to your new (blank) repository. 

The next step is to link our local project repository with the online one. 
To do this, venture into the left pane of the GitKraken Window, where it says 
"REMOTE". Click on the plus" that appears there and a window will open for 
adding a remote (online) repository. You can give it a nickname in the 
"Name" box and then paste in the link to your repository for both the Pull URL 
and Push URL. Click "Add Remote."

The nickname for your online repository should now appear on the left. We 
want to update it with our local copy -- aka, a "push." Click on the push 
button on the top of the GitKraken screen and use the default options. If you 
go to the Github page with your repository, it should now be updated with the 
information you've committed on your computer. 

Through the Github repository page, select a file and edit it (TODO: more 
details). There are now changes in the online copy that are not in your local 
copy. To sync them back up, click the "pull" button in GitKraken. 

Note that we started with a repostiory on a computer and duplicated it online, 
but it can go the other way as well. TODO: cloning w/ GitKraken
    
The moral of the story is that you can create as many copies of a project 
repository as you want, but it's a good idea to choose one of to be "official" 
version that always has the most-up-to-date copy of your changes. Frequently, 
this is the online copy, as it's the easiest to access. 

## Using Local vs Remote Repositories {#py-version-control-local-vs-remote}

In the previous 
However, it's good to consider at least the following two issues when setting up a repository and deciding whether to use local and/or remote copies. 

-   What goes where and why?
    -   local vs. remote storage (physically)
    -   local vs. remote storage (ethical/privacy issues)

##  updating remotes, conflicts

-   How do I manage conflicts?
    -   merge

## To Git-finity, and Beyond {#py-version-control-beyond}

Git was originally developed to manage a BIG and complex software project (development of the Linux operating system kernel) so as a version control system, it's also BIG and complex, with a lot of features that aren't needed for most everyday workflows, especially if you're mostly working by yourself. This chapter has covered what is most essential, and hopefully, most useful. If you find yourself working on more complex projects, especially with multiple collaborators, you may want to learn more about some of git's development and collaboration features. See (book 2?) for more information. 

## Exercises

1. Abbie has started working on a data analysis project. She has a copy of the main data set, and sent her supervisor a preliminary report based on a script she has been writing. The response to her report was a lot of comments, and an updated version of the dataset. Meanwhile, she had a colleague look at her script and he refactored it into a more conventional coding standard. 
Where are some areas where Abbie could use version control to track her work? 

1. Make a change to (file) and commit the changes to the repository. How can you check that the changes were committed? 

1. [TBD: Log output of previous commits]
What command would he use to look at the difference between the repository in its current state and when the commit happened? 

1. Manuel has a copy of his main repository on his laptop, work computer, and Github. If he has done work on his laptop while traveling, what steps does he need to go through to update the copy on his work computer?  What should he have done before starting to work on his laptop to make this go as smoothly as possible? 

[TBD: messages with a merge conflict]
What does this message indicate about the state of the repository? What would you do next? 

1. Which of these is/are examples of remote storage? 
* GitHub
* Google Drive
* an external hard drive

## Key Points {#py-version-control-keypoints}

```{r, child="keypoints/py-version-control.md"}
```

