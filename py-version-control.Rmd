# Version Control {#py-version-control}

## Questions {#py-version-control-questions}


TODO: questions + keypoints
How do you refer to something? Can someone point me at an example?
When do they set up GitKraken / get a github account / install git? 
Is git capitalized?
Should we talk about .gitignore? 
Can revert commits, but not checkout individual files in the GitKraken interface. 

## Objectives {#py-version-control-objectives}

```{r, child="objectives/py-version-control.md"}
```

## Motivation {#py-version-control-motivation}

Have you ever had a folder in your computer that looks like this: 

TODO: picture of file with lots of file names

Or put all your files into an online service like Dropbox or Google Drive,

Or gotten an essay back from a reader with tons of comments in "Track changes" mode: 

TODO: image

You've been doing a kind of version control!

## What is Version Control? {#py-version-control-intro}

Version control is "the management of changes to documents, computer programs, large web sites, and other collections of information." (Wikipedia) In English, that means keeping track of changes to information (in our situtation, information saved in files) in a systematic way. Wikipedia is a great example of a version control system: each page has a record of all the changes that have been made to the page, who made the changes and when, and a way to compare different versions of the page. 

In our world of data science projects, a good version control system should help us track changes like: 

- adding a new dataset to our analysis
- constantly modifying or updating a same script
- getting comments or feedback from a reader
- keeping backup copies of important files

This chapter will focus on a specific version control tool called "git". Git is a program that can be installed on your computer, and you can use it to handle any of the scenarios listed above. There are other version control programs (CVS, SVN, Mercurial are three examples). We've used git in this chapter because it's commonly used and at least two free, online spaces for hosting version controlled work are set up to use git. 

We'll also be using a tool to help us interact with git. We'll be using a program called GitKraken to make it easier to use git, in the same way that we used the Spyder IDE to help us write Python code. 

## Tracking Your Work {#py-version-control-local}

TO get started with tracking work, it's good to think about what scope of information you want to track. Does it make sense to track all of the files of your computer at once? Probably not. It would be better for the version control system to separately track changes on a per-project basis. In terms of how we have files organized on our computer, that means we want to track changes inside a project folder (and all its sub-folders). 

The mechanism used by git to track work is called a "repository" (or "repo" for short) and so for each project where we want to track changes, we need to create a repository associated with the parent folder of the project. 

In the GitKraken interface, there's a button to do exactly that, over on the left: "Start a local repo". It's possible to use this button to associate a repository with a pre-existing folder, but it's simpler to generate a repository in a new folder in one go, so that's what we'll do. 

TODO: Redo this process so I can describe it
TODO: Screenshot

Once this process succeeds, a few things should happen. You should see a folder called `test` on your computer's desktop and the GitKraken screen will suddently become a lot more complicated. Just like with Spyder, we're going to focus on just a part of the window for now - the right hand pane, and the middle section. 

TODO: Screenshot

At this point, we've created a git repository associated with our project folder. Now if we make any changes in that folder (or a sub-folder!), git will pay attention and be able to track it for us. Let's see what happens if we do this. 

"file change in the working directory". If you click on "view Change", the right pane will change to show you the list of files that git knows has changed. In this case...

Our goal is to create a snapshot, called a commit. First task is to add files to the list of files that we want to commit -- this is called *adding* or *staging* files. In the GitKraken interface, this can be done by hitting the "stage all changes" button (which will add *all* the changed files to the list to be committed) or you can click on individual files and then click on the "Stage File" button. 

Once you've done this, the files that are to be added to the commit will be now in the second box of the right pane, the staging area. If you made a mistake and added files you aren't yet ready to snapshot, you can "unstage" them here. Once you have the list of files you want to stage, write a commit message in the third box. Then click on the commit changes to one file. 

We're sent back to our history mode, with the right pane showing us the latest commit. 

git add

git commit

You don't want to commit after every tiny change, but it's a good idea to create commits fairly frequently, so that you have a snapshot of your progress. If changes need to take effect at the same time on a group of files, you should commit them together; if changes are unrelated, it's a good idea to separate them into their own commits. 

git diff
git status
    
This then, is the cycle of making and tracking changes with git: 
- make changes to files in the project repository
- add the changed file to the list of staged changes
- commit those changes, ideally with a meaningful message. 
- use the `diff` and history features to see what changes have been made over time. 

TODO: Image of change cycle

## Looking Back {#py-version-control-history}

One of the scenarios we want our version control system (git) to support is looking at old versions of files.  

The key is finding the commit identifier for the previous version we want to inspect. To do this, make sure you can see the history of commits (with their commit messages!) in the center of the GitKraken window. If you click on one of these, you'll see the right hand pane show all the information associated with the commit, including 

-   How do I view or recover an old version of a file?
    -   diff
    -   checkout --

## Online {#py-version-control-remote}

Finally getting to this.   

-   How do I save work remotely?
    -   push and pull

## Using Local vs Remote Repositories {#py-version-control-local-vs-remote}

In the previous 
However, it's good to consider at least the following two issues when setting up a repository and deciding whether to use local and/or remote copies. 

-   What goes where and why?
    -   local vs. remote storage (physically)
    -   local vs. remote storage (ethical/privacy issues)

##  updating remotes, conflicts

-   How do I manage conflicts?
    -   merge

## To Git-finity, and Beyond {#py-version-control-beyond}

Git was originally developed to manage a BIG and complex software project (development of the Linux operating system kernel) so as a version control system, it's also BIG and complex, with a lot of features that aren't needed for most everyday workflows, especially if you're mostly working by yourself. This chapter has covered what is most essential, and hopefully, most useful. If you find yourself working on more complex projects, especially with multiple collaborators, you may want to learn more about some of git's development and collaboration features. See (book 2?) for more information. 

## Exercises

1. Abbie has started working on a data analysis project. She has a copy of the main data set, and sent her supervisor a preliminary report based on a script she has been writing. The response to her report was a lot of comments, and an updated version of the dataset. Meanwhile, she had a colleague look at her script and he refactored it into a more conventional coding standard. 
Where are some areas where Rhonda could use version control strategies to track her work? What strategies could she use? 

1. Which of these is/are examples of remote storage? 
* GitHub
* Google Drive
* an external hard drive

1. Make a change to (file) and commit the changes to the repository. How can you check that the changes were committed? 

1. [TBD: Log output of previous commits]
What command would he use to look at the difference between the repository in its current state and when the commit happened? 

1. Manuel has a copy of his main repository on his laptop, work computer, and Github. If he has done work on his laptop while traveling, what steps does he need to go through to update the copy on his work computer?  What should he have done before starting to work on his laptop to make this go as smoothly as possible? 

[TBD: messages with a merge conflict]
What does this message indicate about the state of the repository? What would you do next? 

## Key Points {#py-version-control-keypoints}

```{r, child="keypoints/py-version-control.md"}
```

