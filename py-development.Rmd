# Development

## Functions

Functions are like recipes. You give a few ingredients as input to a function,
and it will generate an output based on these ingredients. Just as when
following a recipe, both the ingredients and the instructions will influence
the final result.

In Python, the inputs to a function are not called ingredients, but rather
arguments, and the output is referred to as the return value of the function. A
function does not technically need to return a value, but often does so.
Functions facilitate reusing chunks of code in a way that is more readable and
reproducible than cutting and pasting several lines of code. E.g. if our data
analysis code is broken down into functions, we could readily use it with many
different data sets by changing the input data path, but leaving the rest of
the code the same.

Well chosen function names also clarifies the flow of analysis. For example,
imagine that you open a file with the following lines of code within it.

```{python, eval=FALSE}
images = read_in_images(file_paths)
gray_images = convert_to_grayscale(images)
brightest_image = find_brightest_image(gray_images)
```

Just by looking at the function names, it is clear what this code is intended
for and its main flow of operations is immediately visible. Inside each of
these functions there might be 10-20 lines of code, so if we would not have
modularized the code into separate functions with well chosen names, it
would take longer to understand understand its overall purpose since there
would be 30-60 lines of code to read instead of just three.

### Creating functions

There are many useful functions already built into Python, and the ability to
create your own allows you to string together any sequence of operations in
ways that are tailored to your workflow. The `def` keyword lets us define a
function with a name of our choice and an arbitrary number of input parameters.

```{python}
def sum_two_numbers(num1, num2):
    return num1 + num2
```

This function accepts two input parameters, `num1` and `num2`, and returns
their sum. Just as with variables names, function names are preferably written
in `snake_case`, and avoid existing Python keyword and built-in names (a list of
these is available [here][so-keywords-builtins], but instead of memorizing that
list you can type the desired name into the Python interpreter to find out if
it already exists).

To execute the operations listed in the function, we can call the function
and pass the two numbers we want to add as the arguments to the function.

```{python}
sum_two_numbers(2, 5)
```

The returned value can be assigned to a variable:

```{python}
number_sum = sum_two_numbers(2, 5)
number_sum
```

A more versatile function could add any amount of numbers together and return
their sum:

```{python}
def sum_all_numbers(list_of_numbers):
    number_sum = 0
    for number in list_of_numbers:
        number_sum += number
    return number_sum

sum_all_numbers([1, 2, 3,])
```

A function can also return multiple outputs, e.g. we can return the number of
elements in addition to their sum:

```{python}
def sum_and_len_all_numbers(list_of_numbers):
    number_sum = 0
    number_len = 0
    for number in list_of_numbers:
        number_sum += number
        number_len += 1
    return number_sum, number_len
```

To capture the output, we can either assign to a single name, a tuple, or
assign both at the same time to different variables.

```{python}
sum_and_len_of_numbers = sum_and_len_all_numbers([1, 2, 3])
sum_and_len_of_numbers
```

```{python}
sum_of_numbers, len_of_numbers = sum_and_len_all_numbers([1, 2, 3])
sum_of_numbers
```

```{python}
len_of_numbers
```

> Note: When we defined the function `sum_two_numbers()`, we referred to `num1`
> and `num2` as *parameters*, while we refer to the numbers we pass to the
> function call (`2` and `5` above) as *arguments*. Although this might sound
> confusing at first, it is a standard followed by many programming languages
> so it is useful to get accustomed to this terminology.

#### Function composition

Combining functions is referred to as function composition. This practice
allows us to write functions that perform one specific task and then combine
them for more complicated tasks, which makes code more readable and easier to
debug. By composing a function from the built-in `len()` and `sum()` functions,
we can create a more succinct and easier to read version of our previous
function `sum_and_len_all_numbers()`.

```{python}
def sum_and_len(list_of_numbers):
    return sum(list_of_numbers), len(list_of_numbers)
```

#### Defining default values

Up until now, our function calls have included enough arguments to assign one
to each of the function parameters. This can get tedious in functions with many
parameters and it is often beneficial to define default values for several of
the function parameters. As an example, we can modify `sum_two_numbers()` to
optionally return the two input arguments.

```{python}
def sum_two_numbers(num1, num2, return_input=False):
    if return_input:
        return num1, num2, num1 + num2
    else:
        return num1 + num2
```

By default the function will work just as previously.

```{python}
sum_two_numbers(2, 5)
```

But we now also have the option to return the input numbers.

```{python}
sum_two_numbers(2, 5, return_input=True)
```

Since the arguments are given in the same order as in the function definition,
we could have left out the `return_input=` part and just written `True` in the
third position. If we want to supply the arguments out of order, we need to
specify the parameter name of each argument.

#### Function documentation

Functions might appear self-explanatory when they are being written, but it is
essential that there is proper documentation describing what the function does
and what types of arguments should be in the input. This helps other people who
are reading your code and also your future self that will be reusing these
functions.

In Python, a function is documented in its docstring, which is a multiline
Python string immediately following the function definition. It is surrounded
by triple quotes (either single or double) and can look like this.

```{python}
def sum_two_numbers(num1, num2):
    '''
    Add two numbers

    Args:
        num1 (int, float): The first number to be added.
        num2 (int, float): The second number to be added.

    Returns:
        int, float: Sum of the two numbers.
    '''

    return num1 + num2
```

The above style is commonly referred to as the Google docstring convention. As
functions get longer it can be beneficial to adapt the more elaborate `numpy`
docstring convention used in many scientific Python packages:

```{python}
def sum_two_numbers(num1, num2):
    '''
    Add two numbers

    Parameters
    ----------
    num1: int, float
        The first number to be added.
    num2: int, float
        The second number to be added.

    Returns
    -------
    int, float
        Sum of the two numbers.
    '''

    return num1 + num2
```

We recommend using the `numpy` docstring format since this is easy to read
complex function with many arguments and heavily used by the data science
Python packages. Docstring are what show up in the function help messages, so
it is important that these are well-written and helpful for the user.

```{python}
help(sum_two_numbers)
```

### Applying what we have learnt

Now we can apply what we have learnt about functions on the code we have
written previously.

## How to make programs indicate that something has gone wrong?

When performing programmatic data analysis, we need to both ensure that our
code runs correctly and that it carries out the intended tasks. The Python
interpreter will help us with the first part; if a part of the code is not
valid, an error will be raised with a message that helps us trace back what
part of the code is not correct.

### Ducktyping - relying on Python to detect unexpected behavior

In our function `sum_two_numbers()`, we could explicitly check that the input
arguments are numerical. However, explicitly checking the type of each input
parameter quickly becomes tedious and can make functions less readable,
especially as they grow more complex. An alternative approach is to try to
perform the intended operations on the input parameters and rely on that Python
will raise an error if they are of the wrong type.

```{python error=TRUE}
sum_two_numbers(5, 'six')
```

The raised error contains a helpful message that alerts us to what went wrong;
`string` objects cannot be added to `int` objects in Python. If the input
variables behave correctly then they probably are of the correct types and no
explicit checking is needed. This approach is often referred to as "ducktyping"
because makes assumption on the type of variable based on its behavior, just
like the saying

> If it looks like a duck, swims like a duck, and quacks like a duck, then it
> probably is a duck.

### Assertions - explicitly checking for unexpected behavior

Ducktyping is useful to catch anything that raises an error in Python, but
sometimes we might want to stop the code execution for other reason than a
technical Python error. Examples of this includes when you have performed a
specific operation that you know should give output of a certain shape and to
check if a variable is within an allowed range. The `assert` statement allows
us to check if a condition is `True` and stop code execution if it is not.

```{python error=TRUE}
assert 1 == 0
print('This is only printed if the assertion above is "True"')
```

Since the condition above is `False`, an `AssertionError` is raised and code
execution halts. If the assertion is `True`, there is no output and the next
line of code is executed (if there is one).

```{python}
assert 0 == 0
print('This is only printed if the assertion above is "True"')
```

As mentioned above, this is useful if we know that a variable should look a
certain way, since we can assert if this is the case and guard ourselves from
errors that origin early in the pipeline but could give rise to more cryptic
errors that are difficult to troubleshoot later in the pipeline.

It is often helpful to add a clarifying message to the assertion statement,
especially as assertions become more complex.

```{python error=TRUE}
x = 1
assert x == 0, 'x is not 0'
```

> Note: Similar functionality can be achieved by explicitly raising an error
> within a `try` and `except` block, or within a conditional statement using
> `if`, `elif`, and `else`, but `assert` is a simple and readable way of
> allowing for manual error checking.

## Packages

### Installing Python

There are several ways of installing Python on your system. One of the most
robust and cross-platform compatible is to install the Anaconda Python
distribution, which is [available for Linux, macOS and
Windows](https://www.anaconda.com/distribution/#download-section). Choose to
download the Python 3 installer unless you need to work with Python 2 for a
specific reason.

### Using Python

When the Anaconda installation has finished, Python is accessible by running
`python` in a terminal (on Windows, use the `Anaconda Prompt`). Anaconda also
includes graphical interfaces for interacting with Python, which can be invoked
by running `spyder` or `jupyter-lab` from the command line, these are covered
more in detail elsewhere in this book.

### What is a package

Certain functionality that is considered essential for the Python programming
language is available wherever Python is installed. Other highly useful, but
often more domain specific functionality can be accessed separately in the
form of Python packages. A package is essentially a few Python scripts in a
specific directory structure coupled with installation instructions for the
computer.

> Note: You will sometimes hear packages refers to as "modules". The two
> words are often used interchangeably. Technically, a package is a folder that
> contains modules (scripts), which in turn contains functions (code).

People around the world have created packages for Python and made them freely
available for others to use resulting in one of the richest package ecosystems
for any programming language, with packages for web design, prose writing, game
development, and data science (to name just a few). Since there are so many
packages available, it is infeasible to include all of them with the default
Python installation (it would be as if your new phone came with every single
app from the app/playstore preinstalled). Instead, Python packages can be
downloaded from central repositories online and installed as needed. The two
main repositories are the Python Package Index (PyPi) and the Anaconda package
repository. Instead of navigating to these sites with a web browser,
downloading the desired packages and installing them manually, there are so
called package managers that automate these processes. The package manager for
PyPi is called `pip` and the package manager for Anaconda is called `conda`. To
install a package either of these can be used, below is an example of what to
type on the command line to install the **num**erical **py**thon package
`numpy`.

```bash
conda install numpy
```

```bash
pip install numpy
```

Uninstalling a package is equally simple

```bash
conda remove numpy
```

```bash
pip uninstall numpy
```

Since we have downloaded the Anaconda Python distribution, we will
predominantly be using the `conda` package manager. Installing packages with
both interchangeably works, but it is recommended to stick to one as much as
possible. The Anaconda team has already bundled many commonly used packages
together with their Python installer, including most of the common data science
packages, such as `numpy` and `pandas`.

Now that you know how to access many of the world's best data science
packages right from your terminal, let's see how we can use them!

> Pro tip: Some packages are not available in the default Anaconda repositories. User
   contributed packaged are available in Anaconda "channels", use `anaconda
   search -t conda <package name>`, to find a channel with the desired package.
   To install this package, use `conda install -c <channel name> <package
   name>`. The [conda forge channel](https://conda-forge.github.io/) channel
   has many of the packages not in the default repositories.

### Importing packages

Any installed package can be accessed by typing `import <package_name>` in
Python, e.g.

```{python}
import numpy
```

After importing a Python package, we can access any of its functions, by first
writing the followed by a period and then the function name, e.g.

```{python}
numpy.mean([1, 2, 3])
```

You can think of this as navigating to the numpy menu in a GUI software, and
then clicking the function you want. You don't need to recall every function
name by hard, pressing the <kbd>TAB</kbd> key after the period, will bring up
all available function and intelligently filter them as you type out more
letters, try it! When you start getting familiar with typing function names,
you will notice that this is often faster than looking for functions in menus.

It is common to give packages shorter nicknames, which are faster to type. This
is not necessary, but can save work in long files and make code less verbose so
that it is easier to read:

```{python}
import numpy as np

np.mean([1, 2, 3])
```

We could also import the mean function directly.

```{python}
from numpy import mean

mean([1, 2, 3])
```

And even give it a nickname.

```{python}
from numpy import mean as mn

mn([1, 2, 3])
```

Which of these you use is up to you, but it is common to follow the conventions
established by the library's authors, which for numpy is `import numpy as np`
and use functions via `np.<function_name>`. One thing to avoid is to import
everything from a package, e.g. `from numpy import *`. If this is done with
every package, it is almost guaranteed that the same function name will be
available from more than one package and it will be difficult to keep track of
if you are using the `mean` function from `numpy` or from another package that
you also imported everything from.

Subpackages and their functions can be imported via the dot syntax.

```{python}
from numpy.fft import fftfreq
```

Packages and subpackages might sound complicated to keep apart. It can be
helpful to understand that they are folders and files in specific directory
structure. Considering only the `numpy` packages we have mentioned so far, the
directory structure would look like this.

```
numpy-folder/
    script-with-the-mean-definition.py
    fft-folder/
        script-with-the-fftfreq-definition.py
```

### Installing packages

After Anaconda has been installed on your system, you can use the command line
`conda` package manager or the GUI-driven `anaconda-navigator` to install
Python packages. For comprehensive instructions on both of these, refer to the
[official
documentation](https://docs.continuum.io/anaconda/#navigator-or-conda). Brief
step-by-step instructions to get up and running with `conda` follow.

1. To install a new Python package from the Anaconda repositories, simply run
   `conda install <package name>` in a terminal. You can also use the `pip`
   package manager, but it will be easier to keep track of packages by sticking
   to one installation method.
2. Some packages are not available in the default Anaconda repositories. User
   contributed packaged are available in Anaconda "channels", use `anaconda
   search -t conda <package name>`, to find a channel with the desired package.
   To install this package, use `conda install -c <channel name> <package
   name>`. The [conda forge channel](https://conda-forge.github.io/) channel
   has many of the packages not in the default repositories.

## How to get help online

When reading the built-in Python help is not sufficient, there are several 
online resources that can helpful. One of the most commonly used resources for
data science is the Stack Exchange network wich offer Q&A sites both for
programming related topics via [Stack Overflow][so], as well as statistics and
machine learning via [Cross Validated][cv].

If nothing relevant can be found after searching the many existing question and
answers on these sites, it is appropriate to ask a new question! Stack Overflow
has detailed instruction on how to create a [minimal reproducible
example][so-mre] when asking a question to increase the chances that the
question receives a specific and helpful answer. The key principles listed on
the website recommends that and answer follows these guidelines: 

> - Minimal – Use as little code as possible that still produces the same
> problem
> - Complete – Provide all parts someone else needs to reproduce your problem
> in the question itself
> - Reproducible – Test the code you're about to provide to make sure it
> reproduces the problem

