# Data Manipulation {#r-data-manipulation}

## Questions {#r-data-manipulation-questions}

```{r, child="questions/r-data-manipulation.md"}
```

## Motivation

```{r, message = FALSE, echo = FALSE}
library(tidyverse)
library(here)
dog_licenses <- read_csv(here("data", "nyc-dog-licenses.csv.gz")) %>% 
  drop_na(animal_name)
```

TODO: where is data introduced?

TODO: clean version with no missing values and snake case column names, including month and year columns for some (all?) of the date columns.

TODO: I'm assuming that at some point this data will live in R package, so we can delay importing data to end of chapter.

The RStudio Viewer has an interface much like other spreadsheet programs you might have used.  You can use this Viewer to look at the `dog_licenses` tibble with the `View()` function:
```{r, eval = FALSE}
View(dog_licenses)
```

![](figures/r-data-manipulation/dog-licenses-view.png)

This viewer has some basic data manipulation features:

* **Arrange** You can change the order of the rows in the data based on the values in a column by clicking the up/down arrow next to the column name.

* **Filter** You can filter to include only rows which have a certain value in a column by first clicking the small funnel icon labelled "Filter", then typing a desired value in the appropriate column.

Arrange and filter are known as data manipulation **verbs**.  Individually, they describe a single simple manipulation of a dataset.  It's surprising how many questions you can answer using just these two basic verbs:  

* How old is the oldest dog in this data?  To answer we can arrange the `animal_birth_month` column in increasing order and see Jack, a Pug from Queens, was born in January 1999 (this license was issued in May 2015, making Jack at least 16 at the time).  You'll notice that there are other dogs with this same birthday. 

* What range of license issue dates are in this data?  Arrange `license_issued_date` once in increasing order and once in decreasing order, to find the issue dates range from 12th September 2015 to 31st December 2016.

* How many dogs licenses belong to dogs named Fido? Filter the `animal_name` column with `Fido`, and see "Showing ... of 12 entries" - so 12!  

* and many more...

While these verbs are powerful in their own right, their real power comes from combining them.  For example, we can answer the more complicated question "Which dog named Fido is the oldest?" by first filtering then arranging.

The Viewer in RStudio, however, has two huge limitations:

* It's a point and click interface.  This means to repeat the same operation again you need to remember exactly the steps of point, clicking and typing you performed to get to your answer.  Consequently, it's hard to share those steps unambiguously with someone else, and it's hard to save your results for future.

* The manipulation verbs in the viewer are limited.  There is no way to rearrange the columns, add new variables or calculate summaries like counts or averages.

You'll start this chapter by overcoming this first limitation.  You won't use the Viewer to arrange and filter, you'll learn to write code to do the same operations.  Then you'll increase your vocabulary of data manipulation verbs to include:

* selecting variables,
* adding variables,
* summarizing rows, and 
* performing these operations on subsets of the data.

Combining these verbs you'll be able to answers questions like:

* How long are licences issued for?

* What are the most popular breeds?

* What names are most popular for licensed dogs in New York?  Does this very geographically?

* When are dogs born?

TODO: update these question to reflect things that are actually done in this and later chapters.

To master data manipulation you need to master two pieces:

* How to describe the action you want with the data manipulation verbs individually.  This is a language specific skill - in this chapter, you'll use the functions in the dplyr package.  

* Identifying which verbs, and in which order to apply them, to answer a question of interest.  This skill will translate across all technologies, but it takes a little longer to master.  

### Exercise: Point and click data manipulation

Using the RStudio Viewer answer the following questions:

* How many dog licenses belong to dogs named "Queen" that live in "Queens"?

## Exploring data in the console

Let's take a look at the data in the console:
```{r}
dog_licenses
```

Notice that in contrast to the Viewer you only see the first 10 rows of the dataset, and just the first few columns. The number of columns you see depends on the width of your console, so you may see more or fewer than displayed here.  You should also note some of the contents of the columns have been abbreviated. The `â€¦` at the end of some values in `breed_name` indicates these values have been truncated for display purposes.   

You'll be using the dplyr package for data manipulation. Since it is part of the tidyverse, you'll need to load the tidyverse package to begin:
```{r}
library(tidyverse)
```

### Re-arranging rows 

You can reorder rows of data with the dplyr function `arrange()`. The arrange function takes a tibble as its first argument and column names as the remaining arguments. The result will have the rows ordered in increasing value of the specified column.  For example, to find the licenses belonging to the oldest dogs we arrange `dog_licenses` using the `animal_birth_month` column:
```{r}
arrange(dog_licenses, animal_birth_month)
```
You'll see Jack the Pug that lives in Queens, just like you did in the Viewer.

To arrange the rows by decreasing value, you need to wrap the column name in `desc()`  (short for *desc*ending order).  For instance to find the youngest dogs:
```{r}
arrange(dog_licenses, desc(animal_birth_month))
```

As another example, to find the earliest issue date we can order by increasing `license_issued_date`:
```{r}
arrange(dog_licenses, license_issued_date)
```
The first row is the record with the earliest issue date, but we can't actually see that date because the column `license_issued_date` isn't being displayed due to space.  One solution is to extract only the columns we are interested in, a manipulation known as selecting columns.

### Exercise: Arranging character strings

Use `arrange()` to order the dog licenses by `animal_name` in increasing order.  What does this tell you about the way R treats punctuation and numbers when dealing with alphabetical order?

## How can I select subsets of my data?

Two verbs are used to subset data:

* `select()` to select columns
* `filter()` to select rows

You'll learn about these two functions in this section, along with learning about `%>%`, a way to chain together multiple operations on a dataset.

### Selecting columns

The `select()` function in dplyr is used to extract some subset of columns (but keep all the rows) from a tibble.  Just like `arrange()`, it takes a tibble as its first argument and column names as the remaining arguments.  For example, to keep only the `animal_name` column:
```{r}
select(dog_licenses, animal_name)
```

You can provide additional column names as arguments to keep additional specified columns, for example to keep `animal_name` and `breed_name`:
```{r}
select(dog_licenses, animal_name, breed_name)
```

To return to finding the earliest issue date, you need to first arrange by increasing `license_issued_date` and then select the `license_issued_date` column.  One approach is to store the result of the arrange step,
```{r}
dog_by_date <- arrange(dog_licenses, license_issued_date)
```
Then apply the select step to this object:
```{r}
select(dog_by_date, license_issued_date)
```

There are lots of shortcuts you can use with `select()` to avoid having to type out all the variables you want to keep.  For example, you can ask for all the columns that start with a certain string:
```{r}
select(dog_licenses, starts_with("Animal"))
```
Take a look in the ["Useful functions"][select-docs] section of the `select()` help page for a complete list:
```{r, eval = FALSE}
?dplyr::select
```

### Exercise: Find the latest license issue date

Combine `arrange()` and `select()` to confirm the last issue date in this dataset is 31st December 2016.

### Combining operations with the pipe `%>%`

You've seen you can combine data manipulation steps to do more complicated tasks, but so far you've done so by saving an intermediate object, in our previous example the object `dog_by_date`:
```{r, results="hide"}
dog_by_date <- arrange(dog_licenses, license_issued_date)
select(dog_by_date, license_issued_date)
```

The pipe, `%>%`, is an operator that allows you to chain together operations without intermediate objects and maintain readability.  The name, "pipe", comes from the plumbing kind of pipe, not the smoking kind, and references the idea of objects flowing out of one function and into another. Let's just look at the first step in our manipulation:
```{r, results='hide'}
arrange(dog_licenses, license_issued_date)
```

With the pipe this can be rewritten as:
```{r, results='hide'}
dog_licenses %>% arrange(license_issued_date)
```
The pipe takes the object on the left hand side and passes it as the first argument to the function on the right hand side.  So, here the `dog_licenses` dataset is passed to the first argument of `arrange()`.  Inside `arrange()` we can then list any additional arguments as we normally would.  

The pipe works very nicely with the data manipulation verbs because every verb expects a tibble as its first argument and returns a tibble. This means the result of one operation is easily piped into the next operation, allowing you to chain together multiple steps.  For instance, piping the result of the arrange step above into the `select()` function:
```{r, results = "hide"}
dog_licenses %>% 
  arrange(license_issued_date) %>% 
  select(license_issued_date)
```

When you see the pipe, read it as "and then".  So, the above code would be read:

> Take the dog_licenses data, **and then**   
> arrange the rows by the `license_issued_date`, **and then**  
> select the column `license_issued_date`.

The result is code that matches very closely how we might describe the steps we performed in natural language.  It's so natural that for the remainder of the chapter we'll use the pipe when combining data manipulation steps.

### Exercise: Reading aloud

Read the following code aloud to your neighbor (or cat, dog, or rubber duck).  Remember to pronounce `%>%` as "and then".  
```{r, eval = FALSE}
dog_licenses %>% 
  arrange(license_issued_date) %>% 
  select(license_expired_date)
```

What question might it answer? 

### Exercise:  Using the pipe

Re-write this snippet of code to use the pipe:
```{r, results = "hide"}
select(dog_licenses, animal_name, breed_name)
```

Use the pipe to re-write this snippet of code to avoid the intermediate variable:
```{r, results = "hide"}
name_and_breed <- select(dog_licenses, animal_name, breed_name)
arrange(name_and_breed, breed_name)
```

### Filtering to keep a subset of rows

The function to filter rows of a tibble is `filter()`.  Like `arrange()` and `select()`, its first argument is a tibble.  The remaining arguments describe which rows to **keep**.  The rows to keep are specified with a logical expression - something that is either `TRUE` or `FALSE`. The rows where this expression is `TRUE` will be returned.

One of the simplest kinds of logical expression is a test for equality with the `==` operator.  For example, to keep the rows where `animal_name` is `BRUNO` you could do:
```{r}
dog_licenses %>% filter(animal_name == "BRUNO")
```
You could read this code aloud as:

> Take the dog_licenses data, **and then**   
> filter for only rows when `animal_name` is equal to "BRUNO"

The logical expression, `animal_name == "BRUNO"`, will be `TRUE` when the value of the `animal_name` column is exactly equal to the character string `"BRUNO"` - any differences in characters, case, or whitespace will result in `FALSE`.

Above, each value within a column was compared against the same fixed string (`"BRUNO"`). You can also compare the values from two columns against each other by including a column name on each side of the `==` sign. In programming terms this is known as element-wise comparison.  For example, `license_issued_date == animal_birth_month` will return `TRUE` for a row only if for that row the date the license was issued is the exact same date as the birth month for the dog. If you take a look:
```{r}
dog_licenses %>% 
  filter(license_issued_date == animal_birth_month)
```
There is no output (apart from the column names), which means that no rows satisfy this criteria.

Remember that a string is surrounded by quotes while a column name is not.  When you are reading  code, look for the quotes to figure out if the comparison is to a string, or (by the absence of quotes) to the strings within a column. Use the same strategy to figure out where the quotes should be in your own code, but beware: misplacing quotes often won't result in an error, but instead a result that you weren't expecting.  For example, I might be interested in the licenses issued to male dogs and try:
```{r}
dog_licenses %>% 
  filter("animal_gender" == "M")
```
The result has zero rows, which would suggest there are no such licenses, but in fact this is the answer to a different question.  Can you see what is wrong with the code?  By surrounding `animal_gender` in quotes, R has interpreted the comparison as: is the string `"animal_gender"` equal to the string `"M"`?.  The answer is `FALSE`, and no rows are returned.  I actually wanted to compare the `animal_gender` column to the string `"M"`, so `animal_gender` should have no quotes around it:
```{r}
dog_licenses %>% 
  filter(animal_gender == "M")
```

The operator, `==` (you can read as "is equal to", or simply "equals"), is a specific kind of comparison.  Other comparisons include: 

| Operator | Meaning |
|:--|:--|
| `<` | less than |
| `>` | greater than |
|  `<=` | less than or equal to |
| `>=` | greater than or equal to |
| `!=` | not equal to |

### Exercise: Enterprising dogs

Are there any dogs called "Spock", "Picard", or "Janeway"? 

These are Star Trek characters, can you find any dogs with a name from one of your favorite books, TV shows, or movies?

### Exercise: Expired Licenses

This code creates a variable that contains the date for the start of the year 2016:
```{r}
start_of_2016 <- as.Date("2016-01-01")
```

Use `filter()` with this variable to find:

* The dog licenses that were issued before 2016
* The dog licenses that expire before 2016

### More complicated expressions

If you pass more than one logical expression to `filter()` then `filter()` will return only rows where **all** of the expressions are `TRUE`.  For example, licenses that are to dogs named Bruno in Brooklyn:
```{r}
dog_licenses %>% 
  filter(animal_name == "BRUNO", borough == "Brooklyn") 
```

If you want to create an "or" type expression, like "licenses to dogs named BRUNO **or** dogs named BRUCE", you need to combine two comparisons with the OR operator, `|`.  
```{r, results = "hide"}
# Dogs just named BRUNO
dog_licenses %>% 
  filter(animal_name == "BRUNO")

# Dogs just named BRUCE
dog_licenses %>% 
  filter(animal_name == "BRUCE")

# Dogs named BRUNO or BRUCE
dog_licenses %>% 
  filter((animal_name == "BRUNO") | (animal_name == "BRUCE"))
```
The parentheses around each logical expression are optional, but can help visually to group the components to `|`, especially if those logical expressions get more complicated.

If you find yourself combining lots of comparisons on the same column with `|`, like dogs named `BRUNO`, `BRUCE` or `BRADY`:
```{r, results = "hide"}
dog_licenses %>% 
  filter((animal_name == "BRUNO") | (animal_name == "BRUCE") | (animal_name == "BRADY"))
```
You can save a lot of typing with `%in%`:
```{r, results = "hide"}
dog_licenses %>% 
  filter(animal_name %in% c("BRUNO", "BRUCE", "BRADY"))
```
On the right hand side of `%in%` the function `c()`, **c**combines many single values into a vector. `%in%` will return `TRUE` for an element of the left hand side if it is contained in the vector on the right hand side.

### Exercise: Expired Licenses

This code creates two variables that contain the dates for the start and end of the year 2016:
```{r}
start_of_2016 <- as.Date("2016-01-01")
endt_of_2016 <- as.Date("2016-12-31")
```

Use `filter()` with these variables to find the dog licenses that expire during 2016.

## How can I calculate new values?

So far, you've been manipulating the columns that already exist in a dataset, but what if you want to add new ones? The function `mutate()` handles this kind of operation.  

To see how this works let's start with a logical expression: `animal_name == "CHASE"`.  If you used this with `filter()`, you would get all the rows back where the license was issued to a dog named `CHASE`. Let's say instead of subsetting the data, you want to add a column called `called_chase` that contained the `TRUE` and `FALSE` result. You might do this for example, if you are interested in comparing the two groups of dogs, rather than just keeping one of them. With `mutate()` after passing in the data, you pass named arguments, where the name is the name you desire for the new column, and its value is the way to calculate it:
```{r}
dog_licenses %>% 
  mutate(called_chase = animal_name == "CHASE") %>% 
  select(animal_name, called_chase)
```

> Take `dog_licences`, **and then**,   
> mutate to add a column called `called_chase` which is the result of testing whether `animal_name` is exactly `"CHASE"`, **and then**,   
> select the columns `animal_name` and `called_chase`.

The select statement isn't crucial to the calculation here, but it does help me draw your attention to the columns that were involved in this step.

This can be a useful intermediate step in filtering, since it gives you a chance to examine the logical statement before using it to filter:
```{r}
dog_licenses %>% 
  mutate(called_chase = animal_name == "CHASE") %>% 
  filter(called_chase)
```

Take a closer look at the argument to mutate:
```
called_chase = animal_name == "CHASE"
```
On the left of the `=` is the argument name, `called_chase`.  This is a name you choose - it should be descriptive and follow good style.  On the right of the `=` is an expression that must either return as many values as there are rows, or a single value.  Here, the logical expression involves the column `animal_name` so it returns as many values as there are rows.

If you would prefer the values to be something other than `TRUE` or `FALSE`, instead maybe you want them to be something like `"called chase"` or `"not called chase"`, we would need to use the `ifelse()`.

A call to `ifelse()` takes the form:
```r
ifelse(test, yes, no)
```
Where `test` is a logical expression, `yes` the value for the elements that return `TRUE`, and `no` the value for the elements that return `FALSE`. (Both `yes` and `no` could be other column names, in which case, the corresponding element of `yes` would be returned for `TRUE` elements).
```{r}
dog_licenses %>% 
  mutate(
    called_chase = ifelse(animal_name == "CHASE", "called chase", "not called chase")
    ) %>% 
  select(animal_name, called_chase)
```

FIXME: add diagram showing how ifelse works

You can perform multiple mutate steps at once by passing more arguments to `mutate()`, so an alternative way of writing the above code (with more keystrokes, but with lines that are shorter) would be:
```{r}
dog_licenses %>% 
  mutate(
    is_chase = animal_name == "CHASE",
    called_chase = ifelse(is_chase, "called chase", "not called chase")
    ) %>% 
  select(animal_name, is_chase, called_chase)
```
Notice that the computation for the `called_chase` column refers to the `is_chase` column.  The arguments to mutate are computed in order, so columns created later in the same `mutate()` can refer to columns created earlier.

Arithmetic is another common operation that returns as many elements as there are rows.  For instance we could see how long licenses are issued for:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  select(license_duration)
```
The output shows us licenses aren't issued for a standard time period.  In these first rows, there are some licenses issued for a whole number of years: 2 (731 days), 3 (1097 days) and 5 (1826 days).  However, others seem to be for fractions of years like 421 days.

TODO: provide link to RStudio data mini cheatsheet with other functions that are useful with mutate.

You can use `mutate()` with operations that give one number based on all the rows:
```{r}
dog_licenses %>% 
  mutate(
    license_duration = license_expired_date - license_issued_date,
    avg_duration = mean(license_duration)) %>% 
  select(license_duration, avg_duration)
```
You'll get back the original number of rows, but the single value will be repeated in all of them - on average licenses are issued for 467.321 days.  You'll see a different verb, `summarise()` that collapses many rows into one later in this chapter.

### Exercise: Ages of dogs

Use `mutate()` to add a column `age_at_issue` that contains the dogs approximate age on the day the license was issued.

### Exercise: Unknown breeds

Use `mutate()` along with `ifelse()` to create a column `breed` that takes values `"unknown"` if `breed_name` is `"unknown"` and `"known"` otherwise.

*Extra challenge* Can you figure out if the licenses issued to unknown breed dogs are of longer or shorter duration on average than known breed dogs?

### Exercise: Name length

The function `str_length()` in the stringr package finds the length of character strings.  Replace the `___` in following code to add a column called `name_length` that contains the length of the dog's name:
```{r, eval = FALSE}
dog_licenses %>% 
  ___(___ = stringr::str_length(animal_name))
```

Now add an `arrange()` step to find the licenses issued to dogs with the longest names?

## How can I tell what's gone wrong in my programs?

TODO: The errors shown in the markdown are way more informative than those in the Console.  Try to get the error displaying in the book like they do for someone in the console?

Let me share an interaction my (CVW's) husband had at a Trader Joes (a small specialized supermarket) soon after we arrived in the USA from New Zealand.  

Josh: "Do you sell *bat-trees*?"  

Store-person: "What?"  

Josh: "Do you sell *bat-trees*?"  

Store person: "Huh? *Bat...trees*?"  

Josh: "Do you sell *bat-er-ries*?  

Store-person: "Oh...you mean batteries!  No.  We don't sell batteries."  

This is a pretty accurate analogy for what it feels like when you are learning R.  You know what you want, but you have to ask for it in a way R understands.  When R doesn't understand you, or when R can't give you what you want, you'll get an error.  You'll know when you get one in R because the only output you see will start with `Error`.

```{r, error = TRUE}
buy_batteries(store = "Trader Joes")
```

It's also a good illustration of the two kinds of problems that occur:  syntax errors and runtime errors.  Syntax errors are like the "What? Huh?" moments.  R doesn't understand what you are asking it to do, because something about the way you are asking doesn't conform to what R expects and it will not even try to run your code.  Runtime errors are more like the "No, I can't help you" moments.  R understands what you are asking and runs your code, but during the run something goes wrong and R has to stop running the code.

You generally want to make sure you've ruled out syntax errors before assuming it's a runtime error. Unfortunately, R doesn't distinguish these two types of error in its output, so we'll discuss some of the most common examples in the following sections.

This analogy is also a reminder that sometimes you'll have to repeat yourself.  With R, giving the exact same instruction should always result in the exact same error, but it's not uncommon, even for longtime R users, to run and edit a line of code multiple times before it runs without error.

There is one flaw in this analogy -- R isn't a real person. So, if you need to vent *your* frustration by cursing it, insulting its parentage or storming off, it's fine, no one's feelings will be hurt.  Of course, it won't change R's response...

### Common syntax errors

Syntax errors occur when your code can't be broken into its component pieces by R.  For example, R expects the arguments to a function to start after the opening parenthesis (`(`), be separated by a comma (`,`) and finish at the closing parenthesis (`)`). When R sees this code:
```{r, error = TRUE}
filter(dog_licenses breed_name == "Finnish Lapphund")
```
The missing comma means R can't figure out where the first argument to `filter()` ends: is it after `dog_licenses`, after `breed_name`, or after `==`?  

Take a closer look at the error message.  Error messages always begin with `Error`, then optionally the name of the function that returned an error (not in this example), followed by a `:`, and some description of the error that occurred. The message `unexpected symbol` is one common kind of syntax error - in this case R encountered some code where it was expecting a comma or closing parenthesis.  We can fix it by putting in the missing comma:
```{r, error = TRUE}
filter(dog_licenses, breed_name == "Finnish Lapphund")
```

Syntax errors are usually the result of typos.  Some things to keep an eye out for:

* If you are modelling your code on an example, pay very close attention to the punctuation: commas `,`, parenthesis `(`, `)`, brackets, `[`, `]`, and quotes `"`, `'`.  Every opening parenthesis, bracket, or quote needs a matching closing one, and they must be closed in the reverse order they were opened.  

* New lines don't matter if they happen between arguments, or after pipe operators, but they can be problematic in other locations. 

* R ignores other whitespace (spaces or tabs) unless it's inside a character string (i.e. inside quotes), so different spacing shouldn't be the cause of an error, but it is a good idea to follow good style for spacing.  TODO: link to style guide section.


### Exercise: Syntax errors 

Fix these **syntax** errors. 

*  
    ```{r, error = TRUE}
    dog_licenses %>% 
      arrange(desc(license_expired_date)))
    ```
    
* 
    ```{r, error = TRUE}
    dog_licenses %>% 
      mutate(
        month_born = lubridate::month(animal_birth_month)
        year_born = lubridate::year(animal_birth_month))
    ```

*
    ```{r, error = TRUE}
    dog_licenses %>% 
      filter(animal_name == "BRUNO)
    ```
    (If you run this code in the Console, you might not get an error, but you should see a `+` on a new line, a signal that R is waiting for more input and a clue that there is something missing in this code). 
    
*  
    ```{r, error = TRUE}
    dog_licenses 
      %>% filter(animal_gender == "M")
    ```

### Common runtime errors

Runtime errors come in an infinite number of flavors because there are so many ways that you ask for that might be impossible to do.  For example you might try to do arithmetic with character strings:
```{r, error = TRUE}
"apple" + "banana"
```

Or try to filter with something that isn't a logical:
```{r, error = TRUE}
dog_licenses %>% filter(animal_name)
```

Perhaps the most common runtime error is of the form `Error: object not found`:
```{r, error = TRUE}
an_object_i_dont_have
```
This is R complaining that you've asked it to operate on an object that it doesn't know about.  Often this is actually a typo in disguise, for example you've misspelled the name of the object,
```{r, error = TRUE}
my_object <- 12
my_objet
```
you've used the wrong case, 
```{r, error = TRUE}
My_object
```
or you've forgotten that you've used a separator
```{r, error = TRUE}
myobject
```

This error also often arises when you forgot quotes around strings.  For example, if we want all the dogs that are male, and try
```{r, error = TRUE}
dog_licenses %>% filter(animal_gender == M)
```
you get an error because R is looking for an object called `M` to compare to the values in the column called `animal_gender`.  What we really wanted to do was compare the values in `animal_gender` to the string `"M"`:
```{r}
dog_licenses %>% filter(animal_gender == "M")
```

### Exercise: `object not found`

Fix these `object not found` errors. (Hint: the names of the objects or variables being created should give you a clue to the intent of the code)

*
    ```{r, error = TRUE}
    dog_licenses %>% 
      mutate(year_issued = lubridate::year(Liscenceissuedate))
    ```

* 
    ```{r, error = TRUE}
    dogs_named_bruno <- dog_licenses %>% 
      filter(animal_name == BRUNO)
    ```

### Warnings and messages 

There are two other kinds of alerts R can give: warnings and messages.  These can both appear in the console with the same color as an error, but they are informational as opposed to fatal.  

Messages are purely informational, for example when you read data in with `read_csv()` you get a message that describes the columns and their data types as parsed by the function:
```{r, eval = FALSE}
sites <- read_csv("site.csv")
```
```{r, echo = FALSE}
sites <- read_csv(here("data", "site.csv"))
```

Warnings generally alert you that something was slightly unexpected but that R recovered and gave you a result anyway.  Poorly formatted CSV files will often result in warnings from `read_csv()`:
```{r}
bad_csv <- "
id, 
1, 2
2, 1
3, 5
"
bad <- read_csv(bad_csv)
```
Here there was a missing column name.  `read_csv()` still returns an object but the warning alerts you that it made some assumption to get it, i.e. that it made up a column name:
```{r}
bad
```

Warnings don't **stop** you from proceeding, but they should alert you to question whether you **should be** proceeding.

### What do I do when I get an `Error` I can't fix?

* Check that the error is reproducible.  Restart R with a clean slate and re-run your code up to and including the code that gives the error. This is the R version of the classic tech advice to "turn it off, then turn it on again".  TODO: link to reproducibility chapter.

* Try searching for it online: for example, searching for "R unexpected string constant" lead me to the question ["Error: unexpected symbol/input/string constant/numeric constant/SPECIAL in my code" on StackOverflow][error-unexpected] which gives some great examples of ways this error might arise.

* Ask for help. You are most likely to get help when you can provide a reproducible example. TODO: provide link

## How can I operate on subsets of my data?

The syntax for `summarise()` is the same as `mutate()` but it expects operations that reduce all rows down to one row.  Recall from `mutate()` that this code added the average license duration to every row of the data:
```{r, results="hide"}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  mutate(avg_duration = mean(license_duration)) 
```
You actually saw this in one `mutate()` statement, but I've separated out the line that calculates the average so it's easier to see the difference with `summarise()`.  See what happens when you switch out the final `mutate()` with `summarise()`:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  summarise(avg_duration = mean(license_duration)) 
```
Instead of the the one value repeated on every row, we get a new tibble with only one row, and a single column that corresponds to our requested summary.

Any function that takes many values and reduces them to one is a good candidate for `summarise()`, for example we could find the shortest licence duration by swapping in `min()` instead of `mean()`:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  summarise(shortest_duration = min(license_duration)) 
```

Like `mutate()` you can also create multiple summary columns at once:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration)
  )
```

TODO: link to cheatsheet with list of other useful functions.

Lot's of statistical operations produce one numbers summaries and are appropriate for use with `summarise()`: `sd()`, `min()`, `max()`, `mean()`, `median()`, `quantile()` (with a single argument).  Whenever you are summarizing many rows, it's a good idea to keep track of how many rows were summarized.  This is so common, dplyr provides a special function, `n()`, that simply counts the number of rows.  To add it to your summary:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  )
```

Now, imagine you want this summary just for licenses issued to dogs in the Bronx.  You might do something like:

> Take the `dog_licenses` data, **and then**,   
> mutate to add a column called `license_duration`, **and then**  
> filter to keep rows where the `borough` is `"Bronx"`, **and then**  
> summarise to find the mean, min and max duration along with the number of rows.

In code:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  filter(borough == "Bronx") %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  )
```

But how does this compare to Brooklyn?  You could do the same operation again, but now for Brooklyn:
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  filter(borough == "Brooklyn") %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  )
```

What about Queens?  This kind of operation --- summarising different subsets of the same data --- is so common there is a much easier way to do it: combining `summarise()` with `group_by()`.  

The only difference in the code, is that instead of filtering for a specific `borough` we'll `group_by()` the column `borough`.
```{r}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  group_by(borough) %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  )
```
The `group_by()` verb doesn't perform any changes to the data except to add a signal that this data is now grouped.  Subsequent operations will then happen within these groups.  In the case of `summarise()` we now get one row per group, and these are all stacked together in our result.

You might have been a little surprised by the result above. I thought there were only five boroughs in New York (at least that's what the Beastie Boys told me).  Notice some boroughs are represented more than once by variations in case or spelling: `Bronx`, `BRONX`.  As far as `group_by()` is concerned these are distinct values of this variable.  There also seem to be smaller designations than Borough in this data. You'll get a chance to try and resolve this in an exercise below.

### Exercise: Dog birth months

The following code creates a new column `month_born` that holds the name of the month the licensed dog was born:
```{r, results = "hide"}
dog_licenses %>% 
  mutate(month_born = lubridate::month(animal_birth_month, label = TRUE))
```
Use a `group_by()` step and a `summarise()` step to find the number of dogs born in each month.  Which month stands out? Can you guess why?

### Exercise: Order matters?

In the example above for dogs licensed in Brooklyn:
```{r, results = "hide"}
dog_licenses %>% 
  mutate(license_duration = license_expired_date - license_issued_date) %>% 
  filter(borough == "Brooklyn") %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  )
```
the `filter()` step came after the `mutate()` step. Does this matter?  

* Swap the order in the code and see if you get the same results.

* Write out how you might describe the steps. Is it obvious you can swap the filter and mutate step and get the same results?

* Which steps can't you swap the order of? Why?

* *Despite giving the same results, some orderings of the data manipulation steps will take longer to compute. Can you guess why?*

### Exercise: the five boroughs

The column `neighborhood_tabulation_area` is a code for the "Neighborhood Tabulation Areas", and has been geo-coded from the licensee's address (as opposed to self reported).  The first two characters correspond to the Borough.

This code creates a new variable called `borough_code` that contains just these two characters:
```{r}
dog_licenses %>% 
  mutate(borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) 
```

Which borough has the longest average licence duration?

## How can I work with two or more datasets?

So far all the manipulation verbs you have seen work on a single table of data.  But what if your questions involve data spread across more than one dataset?  As an example, consider the question: which neighborhood has the highest proportion of dog ownership in 2016?  You can get a handle on how many dog are licensed during 2016 for each neighborhood using the manipulations you've seen so far:
```{r}
dogs_by_nta <- dog_licenses %>% 
  filter(
    license_issued_date >= as.Date("2016-01-01"), 
    license_issued_date <= as.Date("2016-12-31")
    ) %>% 
  group_by(neighborhood_tabulation_area) %>% 
  summarise(n_licences = n()) %>% 
  arrange(desc(n_licences))
dogs_by_nta
```

Looks like MN12 has the most licenses, but what neighborhood is this?  And are there many licenses because a high proportion of people own dogs, or just that there are lots of people in this neighborhood?  To answer both of these questions you would need to combine this data with additional data, say that contained in `nyc-nta-pop`
```{r, eval = FALSE}
nta_pop <- read_csv("nyc-nta-population.csv")
```
```{r, echo = FALSE}
nta_pop <- read_csv(here("data", "nyc-nta-population.csv"))
```

```{r}
nta_pop
```

This data includes populations for each NTA and a full name for the NTA.  If you look at the neighborhoods with the largest populations:
```{r}
nta_pop %>% 
  arrange(desc(population)) %>% 
  select(nta_code, nta_name, year, population, year)
```
You'll see that MN12, the Upper West Side, in fact has the largest population of all the neighborhoods (at least in 2000 and 2010), so perhaps it isn't surprising it also has the most dog licenses issued in 2016.

Joins are a way to combine two datasets together by using a column the datasets have in common - like the columns that contain the NTA codes.  Let's work with some smaller datasets to see how this works.  
```{r, include = FALSE}
dogs <- tribble(
  ~animal_name,  ~nta, ~breed_name,
  "PRECIOUS",  "QN12",  "Yorkshire Terrier",
  "TOBY",      "QN55",  "Jack Russell Terrier",
  "GUCCI",     "QN01",  "Yorkshire Terrier",
  "HUNTER",    "QN12",  "Unknown", 
)
neighborhoods <- nta_pop %>% 
  filter(nta_code %in% c("QN01", "QN02", "QN03", "QN12"), year == 2010) %>% 
  select(nta = nta_code, population, nta_name)
```

One dataset might have rows that correspond to dogs, and their neighborhood:
```{r}
dogs
```

Another dataset might have rows that correspond to neighborhoods and their populations:
```{r}
neighborhoods 
```
Notice the datasets both have a column called `nta`, and this column contains the NTA code. {TODO: either point out this isn't true in full size data, or make it true by changing data.} This provides a way to match rows in `dogs` to the rows in `neighborhoods`: for each row of `dogs`, look up the value of `nta` in `neighborhoods` and return the values of `population` and `nta_name`.  This might result in a new dataset that looks like this: 
```{r, echo = FALSE, message = FALSE}
dogs %>% left_join(neighborhoods)
```
Both "PRECIOUS" and "HUNTER" live in Hammels-Arverne-Edgemere with a population of 36,885 and "GUCCI" lives in South Jamaica with a population of 38,894.  Notice that "TOBY" has missing values for both `population` and `nta_name` because his value of `nta`, `"QN55"`, wasn't in this small `neighborhoods` data.  

This join can be performed with the `left_join()` function in dplyr:
```{r}
dogs %>% left_join(neighborhoods)
```
It's called a `left_join()` because we will get (at least) one row back for every row in the dataset on the left, in this case, `dogs`.  I like to think about `left_join()` working just as we described above: for each row in the dataset on the left, look up the value in the dataset on the right. 

Notice that `left_join()` gave us the message `Joining, by = "nta"`.  The join functions in dplyr will use any columns with the same name in both datasets to do the join.  If the datasets have columns for the same quantity but with different names, for instance, if instead of `neighborhoods`, you had the dataset `neighborhoods_2` with a column called `nta_code` instead of `nta`:
```{r, include = FALSE}
neighborhoods_2 <- neighborhoods %>% 
  rename(nta_code = nta)
```{r}
neighborhoods_2 
```

Then attempting the join will result in an error - `data sources have no common variables`:
```{r, error = TRUE}
dogs %>% left_join(neighborhoods_2)
```
You can use the `by` argument to the join function to specify which columns are to be used to do the join:
```{r}
dogs %>% 
  left_join(neighborhoods_2, by = c("nta" = "nta_code"))
```
The value passed to `by` is a named character vector and is created using the form
```
c("<< Name of column in LHS dataset >>" = "<< Name of column in RHS dataset >>")
```
The `by` argument in the example above, 
```{r, results = "hide"}
c("nta" = "nta_code")
```
specifies the join column is `"nta"` in `dogs`, and `"nta_code"` in `neighborhoods_2`.

### Exercise: Predicting the output of a join

Try to predict what this code will return, then run it and check your prediction:
```{r, results = "hide", message = FALSE}
neighborhoods %>% left_join(dogs)
```

### Exercise: Dog licenses per capita

* Use `left_join()` to join `dogs_by_nta` with `nta_pop`. 

* `filter()` the result to only use population from `year` 2010.

* Add a `mutate()` step to find the number of dog licenses per person in each NTA.

* Which neighborhood has the highest dog licenses per person based on the 2010 population?

```{r, include = FALSE}
dogs_by_nta %>% 
  left_join(nta_pop, by = c("neighborhood_tabulation_area" = "nta_code")) %>% 
  mutate(licenses_per_person = n_licences/population) %>% 
  filter(year == 2010) %>% 
  arrange(desc(licenses_per_person)) %>% 
  select(nta_name, licenses_per_person)
# Stuyvesant Town-Cooper Village averages 0.045 dogs per person
# Or ~45 dogs per 1000 people
```

### Other join functions

Like `left_join()` all the join functions in dplyr also end in `_join` and take two datasets as arguments.  You can see the full list in:
```{r, eval = FALSE}
?dplyr::join
```

The functions `inner_join()`, `left_join()`, `right_join()` and `full_join()` all take two datasets and return a single dataset with **all the columns** from both.  They differ in the treatment of rows with no matches:

* `left_join()`, as you've seen, keeps rows in the left hand dataset, but if there is no match in the right hand dataset, columns from the right hand dataset are given missing values.
    ```{r}
    dogs %>% left_join(neighborhoods)
    ```

* `right_join()`, is just like `left_join()` but with the roles of the data sets reversed.
    ```{r}
    dogs %>% right_join(neighborhoods)
    ```

* `inner_join()` returns only rows that have matches.
    ```{r}
    dogs %>% inner_join(neighborhoods)
    ```

* `full_join()` returns all rows from both datasets, using missing values in columns where a row doesn't have a match in the other dataset.
    ```{r}
    dogs %>% full_join(neighborhoods)
    ```

Another useful join is `anti_join()`.  It doesn't actually return a combined dataset, you only get columns from one dataset back, but it returns the rows in the left hand dataset with no matches in the right hand dataset.  This is a great way to explore what you might be missing.  For example, it makes it easy to ask which rows in `dogs` don't have matches in `neighborhoods`:
```{r}
dogs %>% anti_join(neighborhoods)
```

With the full size data, there aren't any NTAs for licensed dogs that aren't in our population data:
```{r}
dogs_by_nta %>% 
  anti_join(nta_pop, by = c("neighborhood_tabulation_area" = "nta_code")) 
```

But there are a few NTAs in the population data, with no licensed dogs:
```{r}
nta_pop %>% 
  anti_join(dogs_by_nta, by = c("nta_code" = "neighborhood_tabulation_area")) 
```
Perhaps it's not surprising that there aren't any dogs licensed in the airport or cemetery.  What about Rikers Island? You might try a web search to see if you can figure out why none of the ~12,000 residents have dogs.

### Exercise

```{r, eval = FALSE, include = FALSE}
set.seed(01819)
library(babynames)

dog_counts <- dog_licenses %>% 
  filter(animal_gender == "F", lubridate::year(animal_birth_month) == 2016) %>% 
  group_by(animal_name) %>% 
  summarise(n_dogs = n()) %>% 
  rename(name = animal_name)

five_baby_names <- 
  babynames %>% 
  filter(year == 2016, sex == "F") %>% 
  mutate(name = toupper(name)) %>% 
  rename(n_babies = n) %>% 
  semi_join(dog_counts) %>% 
  sample_n(size = 5) %>% 
  select(name, n_babies)

# datapasta::tribble_paste(five_baby_names)
# datapasta::tribble_paste(dog_counts %>% semi_join(five_baby_names))
```
Consider the following two datasets, one with a count of the number of babies (human) born in 2016 for five names:
```{r}
babynames <- tribble(
      ~name, ~n_babies,
   "CLAIRE",     5207L,
     "ZURI",      889L,
     "SUZY",       20L,
    "VICKI",       13L,
  "CHELSEA",      929L
  )
babynames
```

And one with the number of dogs licensed in New York whose birth month is in 2016:
```{r}
dognames <- tribble(     
      ~name, ~n_dogs,
  "CHELSEA",      1L,
   "CLAIRE",      2L,
     "SUZY",      3L,
    "VICKI",      1L,
     "ZURI",      1L
  )
dognames
```

* Use `left_join()` to combine the datasets.

* Why doesn't this join work?  Can you fix it?
```{r}
babynames_2 <- tribble(
      ~name, ~n,
   "CLAIRE",     5207L,
     "ZURI",      889L,
     "SUZY",       20L,
    "VICKI",       13L,
  "CHELSEA",      929L
  )
dognames_2 <- tribble(     
      ~name,      ~n,
  "CHELSEA",      1L,
   "CLAIRE",      2L,
     "SUZY",      3L,
    "VICKI",      1L,
     "ZURI",      1L
  )
left_join(babynames_2, dognames_2)
```

* Why doesn't this join work?  Can you fix it?
```{r}
babynames_3 <- tribble(
      ~name, ~n_babies,
   "Claire",     5207L,
     "Zuri",      889L,
     "Suzy",       20L,
    "Vicki",       13L,
  "Chelsea",      929L
  )
dognames_3 <- tribble(     
      ~name,      ~n_dogs,
  "CHELSEA",      1L,
   "CLAIRE",      2L,
     "SUZY",      3L,
    "VICKI",      1L,
     "ZURI",      1L
  )
left_join(babynames_3, dognames_3)
```


### Exercise

Find the dog licences per capita, but now at the community district level, by joining the `dog_licenses` data with the `nyc-cd-pop` data.

## How can I read my own tabular data into R?

### What is tabular data?

Tabular data describes data that is in the form of a table: values arranged in rows each of the same length, or equivalently values arranged in columns each of the same length. Here's a small example of some tabular data:
```{r, echo = FALSE, message=FALSE}
example_csv <- here("data", "site.csv")
sites <- read_csv(example_csv )
knitr::kable(sites)
```

Each row records information on a site at which water measurements are taken.  There are three columns: a site identification code, and the location of the site in latitude and longitude. 

This is an incredibly common way of *displaying* data, but when *storing* tabular data in a file, we need a way to communicate when records and values begin and end.  A very popular format for doing this is CSV.  CSV, is short for **c**omma **s**eparated **v**alues, and like the name suggests, a comma, `,`, is used to separate the values for each column, while each record goes on a new line.  The file is plain text, but we use the extension `.csv` to indicate that is follows the CSV format conventions.

Here's how the table above would look inside the CSV file `site.csv`:
```{r, echo = FALSE, comment = NA}
writeLines(readLines(example_csv))
```

In this case the first line has the column names, this is common (and recommended!), but not universal. 

Why is CSV so popular? 

* It's human readable.  CSV isn't a special file type, it is a simple plain text file that follows some conventions.  This means you don't need any special software to look at the contents -- you can open it up in anything that can examine text and take a look inside. 
* It's computer readable.  Because CSV files all have the same structure it's easy to write computer programs to read them.  This means in almost any program designed to work with data, which is basically all the common programming languages, you'll find functions that will import CSV files.  This also means it's easy to create CSV files -- you can export them from Excel, write them from R, or even write one from scratch in a text editor.

If you want to look inside a CSV file in RStudio you can navigate to its location in the "Files" pane and click on its name.  Selecting "View File", will open it in the Source pane. 

However, if you want to work with CSV data in R, it isn't enough to look inside the file.  You need to read the contents of the file and store it in R's memory.  This process is known as data import.

### Importing CSV data into R

To work with data in R you need to have it in R's memory.  The `read_csv()` function in the readr package will import a CSV file, and represent it as a tibble, if you give it the location of the CSV file.  For example, to read the `site.csv` data and store it in an object called `sites`: 
```{r}
library(tidyverse)
sites <- read_csv(here("data", "site.csv"))
sites
```

TODO: talk about files paths, point reader to the place where file paths are talked about, or assume file is in their working directory.

Notice that `read_csv()` gave us a message about what it did: it parsed our data file and found three columns `site_id`, `latitude` and `longitude`.  It also mentions what kind of data it assumed was in each column.  TODO: point to further discussion of data types.

The object `sites` is now R's representation of the data from the `site.csv` file.    

### Exercise: Import `visited.csv`

Use `read_csv()` to read `visited.csv` into R. How does R indicate a cell with a missing value?

```{r}
visited <- read_csv(here("data", "visited.csv"))
visited
```

### Exercise: Import IRS tax return data for New York City

Use `read_csv()` to import the CSV file `nyc-tax-returns.csv`.  

TODO: Should we introduce the "common things that go wrong" / "the most common additional arguments", e.g. `skip`, `na`, `col_names`, `col_types`?  My feeling is not now, but sometime later.

## How can I save my results?

Say, you've now got a summary of the license durations by borough:
```{r}
dog_licenses %>% 
  mutate(
    license_duration = license_expired_date - license_issued_date,
    borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) %>% 
  group_by(borough_code) %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  ) 
```

How do you save this result for future use?

If you just need this tibble later in your code you can assign it to a variable:
```{r}
duration_by_borough <- dog_licenses %>% 
  mutate(
    license_duration = license_expired_date - license_issued_date,
    borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2)) %>% 
  group_by(borough_code) %>% 
  summarise(
    avg_duration = mean(license_duration),
    shortest_duration = min(license_duration),
    longest_duration = max(license_duration),
    n_licenses = n()
  )
```

Then you can access it whenever you need it:
```{r}
duration_by_borough 
```

This keeps our result around in memory, but often you also want to preserve the data in a file on disk.  There are two common choices for format: CSV and RDS.

You've already seen CSV files.  Saving your results in this format gives you all the benefits of that format: plain text files easily shared and opened.  You can save a tibble as a CSV file with the readr function `write_csv()`, where all you need to specify is the path:
```{r}
duration_by_borough %>% write_csv("duration-by-borough.csv")
```

You can then read this file in any project or R session with `read_csv()`:
```{r}
duration_by_borough <- read_csv("duration-by-borough.csv")
```

RDS files are a special R format.  They are binary files as opposed to plain text files, which means you can't just open them up and look inside.  If you are sharing them you'd also need your collaborators to have R.  These are downsides, but the advantage of this format is that it can be much quicker to load, it will preserve special R data types (for example factors, or nested structures), and can save any R object not just tabular data structures.

To save the tibble as an RDS, use `write_rds()`:
```{r}
duration_by_borough %>% write_rds("duration-by-borough.rds")
```

To read it back in, use `read_rds()`:
```{r}
duration_by_borough <- read_rds("duration-by-borough.rds")
```

Often you'll save your data in both formats to make sure you get the best of both worlds. You'll talk more about where to save your data in TODO: add link.

### Exercise

Save the tibble with our extra columns:
```{r, results = "hide"}
dog_licenses %>% 
  mutate(
    license_duration = license_expired_date - license_issued_date,
    borough_code = stringr::str_sub(neighborhood_tabulation_area, 1, 2))
```

into a CSV file called `dog-licenses-extra.csv`.
